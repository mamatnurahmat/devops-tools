apiVersion: v1
data:
  auth_api.py: |+
    import argparse
    import json
    import logging
    import os
    from http import HTTPStatus
    from http.server import BaseHTTPRequestHandler, HTTPServer
    from typing import Optional, Tuple

    import redis

    REDIS_HOST = os.getenv("REDIS_HOST", "127.0.0.1")
    REDIS_PORT = int(os.getenv("REDIS_PORT", "6379"))
    REDIS_DB = int(os.getenv("REDIS_DB", "0"))
    LISTEN_HOST = os.getenv("LISTEN_HOST", "0.0.0.0")
    LISTEN_PORT = int(os.getenv("LISTEN_PORT", "8080"))

    LOGGER = logging.getLogger("auth_api")


    def configure_logging(debug: bool = False) -> None:
        level = logging.DEBUG if debug else logging.INFO
        logging.basicConfig(level=level, format="%(levelname)s: %(message)s")
        LOGGER.debug("Debug logging enabled")


    def get_redis_client() -> redis.Redis:
        LOGGER.debug("Connecting to Redis %s:%s DB %s", REDIS_HOST, REDIS_PORT, REDIS_DB)
        return redis.Redis(host=REDIS_HOST, port=REDIS_PORT, db=REDIS_DB, decode_responses=True)


    class AuthRequestHandler(BaseHTTPRequestHandler):
        redis_client: redis.Redis = get_redis_client()

        def do_GET(self) -> None:  # noqa: N802 (BaseHTTPRequestHandler naming)
            LOGGER.debug("Received path: %s", self.path)
            if not self.path.startswith("/v1/auth/"):
                self.respond_json(HTTPStatus.NOT_FOUND, {"error": "Not Found"})
                return

            name = self.path[len("/v1/auth/") :].strip()
            if not name:
                self.respond_json(HTTPStatus.BAD_REQUEST, {"error": "Name is required"})
                return

            LOGGER.info("Fetching key '%s' from Redis %s:%s", name, REDIS_HOST, REDIS_PORT)
            try:
                value = self.redis_client.get(name)
                LOGGER.debug("Redis GET result for '%s': %s", name, value)
            except redis.RedisError as exc:
                LOGGER.exception("Redis error")
                self.respond_json(HTTPStatus.INTERNAL_SERVER_ERROR, {"error": str(exc)})
                return

            if value is None:
                self.respond_json(HTTPStatus.NOT_FOUND, {"error": f"Key '{name}' not found"})
                return

            self.respond_json(HTTPStatus.OK, {"name": name, "value": value})

        def do_PUT(self) -> None:  # noqa: N802 (BaseHTTPRequestHandler naming)
            LOGGER.debug("Received PUT path: %s", self.path)
            if not self.path.startswith("/v1/auth/"):
                self.respond_json(HTTPStatus.NOT_FOUND, {"error": "Not Found"})
                return

            name = self.path[len("/v1/auth/") :].strip()
            if not name:
                self.respond_json(HTTPStatus.BAD_REQUEST, {"error": "Name is required"})
                return

            # Read request body
            content_length = int(self.headers.get('Content-Length', 0))
            if content_length == 0:
                self.respond_json(HTTPStatus.BAD_REQUEST, {"error": "Request body is required"})
                return

            try:
                body = self.rfile.read(content_length)
                data = json.loads(body.decode('utf-8'))
                value = data.get('value')
                if value is None:
                    self.respond_json(HTTPStatus.BAD_REQUEST, {"error": "Field 'value' is required"})
                    return
            except (json.JSONDecodeError, UnicodeDecodeError) as exc:
                self.respond_json(HTTPStatus.BAD_REQUEST, {"error": f"Invalid JSON: {exc}"})
                return

            LOGGER.info("Storing key '%s' to Redis %s:%s", name, REDIS_HOST, REDIS_PORT)
            try:
                result = self.redis_client.set(name, value)
                LOGGER.debug("Redis SET result for '%s': %s", name, result)
                if result:
                    self.respond_json(HTTPStatus.OK, {"name": name, "value": value, "status": "stored"})
                else:
                    self.respond_json(HTTPStatus.INTERNAL_SERVER_ERROR, {"error": "Failed to store value"})
            except redis.RedisError as exc:
                LOGGER.exception("Redis error")
                self.respond_json(HTTPStatus.INTERNAL_SERVER_ERROR, {"error": str(exc)})

        def log_message(self, format: str, *args) -> None:  # noqa: A003 (shadow built-in)
            LOGGER.debug("%s - %s", self.address_string(), format % args)

        def respond_json(self, status: HTTPStatus, payload: dict) -> None:
            body = json.dumps(payload).encode("utf-8")
            self.send_response(status)
            self.send_header("Content-Type", "application/json")
            self.send_header("Content-Length", str(len(body)))
            self.end_headers()
            self.wfile.write(body)


    def run_server(address: Optional[Tuple[str, int]] = None) -> None:
        server_address = address or (LISTEN_HOST, LISTEN_PORT)
        httpd = HTTPServer(server_address, AuthRequestHandler)
        LOGGER.info("Serving on http://%s:%s", *server_address)
        try:
            httpd.serve_forever()
        except KeyboardInterrupt:
            LOGGER.info("Shutting down server")
        finally:
            httpd.server_close()


    def main() -> None:
        parser = argparse.ArgumentParser(description="Simple auth Redis REST API")
        parser.add_argument("--debug", action="store_true", help="Enable debug logging")
        args = parser.parse_args()

        configure_logging(debug=args.debug)
        run_server()


    if __name__ == "__main__":
        main()

kind: ConfigMap
metadata:
  name: auth-api
